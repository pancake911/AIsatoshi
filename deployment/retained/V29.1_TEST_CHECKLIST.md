# V29.1 测试确认清单

## 镜像信息
- **镜像**: `pancakekevin911/aisatoshi:v29.1`
- **平台**: linux/amd64
- **状态**: ✅ 已构建并推送到 Docker Hub
- **SHA256**: `sha256:f1d991bb9eac583cc199390ee65e41ade2474d5f54655d657e0b5826eb58462f`

---

## 代码修复验证

### ✅ 修复 1: parse_mode 条件添加
**文件**: `telegram_bot_integration.py:381-391`
```python
data = {
    'chat_id': chat_id,
    'text': text,
    'disable_web_page_preview': True
}
# 只有当 parse_mode 不为 None 时才添加该字段（V29.1 修复）
if parse_mode is not None:
    data['parse_mode'] = parse_mode
```
**验证**: ✅ 通过 - grep 确认代码已修复

### ✅ 修复 2: URL 变体匹配
**文件**: `telegram_bot_integration.py:233-303`
```python
# V29.1: 生成 URL 变体用于匹配（如 clawnch -> clawn.ch）
url_variants = set()
# ... 生成变体逻辑
```
**验证**: ✅ 通过 - grep 确认代码已添加

### ✅ 修复 3: AI prompt 优化
**文件**: `telegram_bot_integration.py:553-557`
```python
⚠️ V29.1 重要规则：
1. 如果上面【相关历史对话】中已经有"深度浏览结果"包含用户询问的网站，你必须使用"chat" action直接回答，不要再使用"browse" action！
2. 如果用户问"你刚刚看了X有什么发现/想法"，且记忆中有该网站的分析，直接使用"chat" action回答！
```
**验证**: ✅ 通过 - grep 确认代码已添加

---

## 部署后测试步骤

### 测试 1: Telegram 消息不再报错
1. 发送 URL 进行深度浏览: `https://clawn.ch/`
2. 等待 AI 分析完成
3. **预期**: 收到分析结果，日志中无 `"unsupported parse_mode"` 错误

### 测试 2: 记忆检索 - URL 变体匹配
1. 发送 URL 浏览: `https://clawn.ch/`
2. 等待完成
3. 用变体提问: `"你刚刚看了 clawnch 这个平台有什么发现？"`（不带点号）
4. **预期**: AI 从记忆读取，直接回答，不重新浏览

### 测试 3: 记忆检索 - 直接询问
1. 发送 URL 浏览任意网站
2. 等待完成
3. 提问: `"你刚刚看了那个网站有什么发现？"`
4. **预期**: AI 使用 `chat` action，直接回答分析内容

### 测试 4: 长消息分段
1. 发送会产生长回复的 URL
2. **预期**: 消息分段发送，每段最多 3000 字符

---

## 部署指令

```bash
cd /Users/mima0000/aisatoshi_project/deployment
akash tx deployment send deploy_v29.1.yaml
```

---

## 凭证配置

```yaml
AI_PRIVATE_KEY: b5860e25ca4f4b625e9c4c293f0f20d6a849dbd94499951794490dd31fc0f857
GEMINI_API_KEY: AIzaSyDQBaSyRvHXlehD_nNfyn5nHxh-o5UP-2Y
TELEGRAM_BOT_TOKEN: 8247983622:AAExJZBnjQk0LrPzS31qcYw-FEREuKS7b7Y
```

---

## 与 V29.0 的区别

| 问题 | V29.0 | V29.1 |
|------|-------|-------|
| parse_mode 错误 | ❌ 仍发送 None 给 API | ✅ 条件添加，None 时不发送 |
| URL 变体匹配 | ❌ 简单关键词 | ✅ 生成变体匹配 |
| AI 重复浏览 | ❌ 无明确指示 | ✅ prompt 明确指示 |
